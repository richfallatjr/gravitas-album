Gravitas Reader — UI Styling + Curved Layout + Scroll + Pagination Blueprint
==========================================================================

Goal
----
This document is a “drop-in context” file for another AI (or future-you) that needs to recreate
Gravitas Reader’s look + immersive curved layout behavior:

- A palette-driven styling system (light/dark) used everywhere
- An immersive curved “wall/arc” layout of paged panels
- A single large vertical ScrollView layout mode (for books / narrow format)
- Paged pagination with Prev/Next nav cards
- IMPORTANT: deterministic immersive-space spawn positions (boards dropped in-world)

If you copy these patterns into another project, keep the numeric constants EXACT unless you are
intentionally changing the geometry. The placement math is tuned together.


1) Styling system (palette-first)
---------------------------------

We don’t style views ad-hoc. We define a small palette of semantic colors and pass it through
views (`palette: ReaderThemePalette`), with the app deciding which palette to use.

Source of truth is `ReaderTheme` → `ReaderThemePalette`:
- `Sources/GravitasReader/ReaderState.swift`

Key idea:
- Views never ask “am I dark mode?”; they ask for `palette.primaryText`, `palette.cardBackground`, etc.

Code (verbatim excerpt):

```swift
// Sources/GravitasReader/ReaderState.swift

enum ReaderTheme: String, Codable, CaseIterable {
    case light
    case dark

    var palette: ReaderThemePalette {
        let readAccent = Color(red: 169.0/255.0, green: 220.0/255.0, blue: 118.0/255.0)
        let historyAccent = Color(red: 171.0/255.0, green: 157.0/255.0, blue: 242.0/255.0)
        let openAccent = Color(red: 255.0/255.0, green: 97.0/255.0, blue: 136.0/255.0)
        let toggleAccent = Color(red: 255.0/255.0, green: 216.0/255.0, blue: 102.0/255.0)
        let copyAccent = Color(red: 120.0/255.0, green: 220.0/255.0, blue: 232.0/255.0)

        switch self {
        case .light:
            return ReaderThemePalette(
                cardBackground: Color(.sRGB, white: 1.0, opacity: 1.0),
                cardBorder: Color.black.opacity(0.08),
                primaryText: .black,
                secondaryText: Color(.sRGB, white: 0.35, opacity: 1.0),
                captionText: Color(.sRGB, white: 0.42, opacity: 1.0),
                overlayText: Color(.sRGB, white: 0.45, opacity: 1.0),
                navBackground: Color(.sRGB, white: 0.98, opacity: 0.97),
                navBorder: Color.black.opacity(0.08),
                navIconActive: .black,
                navIconDisabled: .black.opacity(0.35),
                panelBackground: Color(.sRGB, white: 0.95, opacity: 1.0),
                panelPrimaryText: .black,
                panelSecondaryText: Color(.sRGB, white: 0.35, opacity: 1.0),
                readButtonColor: readAccent,
                historyButtonColor: historyAccent,
                openButtonColor: openAccent,
                toggleFillColor: toggleAccent,
                toggleIconColor: .white,
                copyButtonFill: copyAccent,
                copyIconColor: .black,
                buttonLabelOnColor: .white
            )
        case .dark:
            return ReaderThemePalette(
                cardBackground: Color(.sRGB, white: 0.10, opacity: 0.92),
                cardBorder: Color.white.opacity(0.16),
                primaryText: .white,
                secondaryText: Color.white.opacity(0.72),
                captionText: Color.white.opacity(0.6),
                overlayText: Color.white.opacity(0.7),
                navBackground: Color(.sRGB, white: 0.08, opacity: 0.92),
                navBorder: Color.white.opacity(0.18),
                navIconActive: .white,
                navIconDisabled: Color.white.opacity(0.38),
                panelBackground: Color(.sRGB, white: 0.12, opacity: 0.94),
                panelPrimaryText: .white,
                panelSecondaryText: Color.white.opacity(0.72),
                readButtonColor: readAccent,
                historyButtonColor: historyAccent,
                openButtonColor: openAccent,
                toggleFillColor: toggleAccent,
                toggleIconColor: .black,
                copyButtonFill: copyAccent,
                copyIconColor: .black,
                buttonLabelOnColor: .black
            )
        }
    }
}

struct ReaderThemePalette {
    let cardBackground: Color
    let cardBorder: Color
    let primaryText: Color
    let secondaryText: Color
    let captionText: Color
    let overlayText: Color
    let navBackground: Color
    let navBorder: Color
    let navIconActive: Color
    let navIconDisabled: Color
    let panelBackground: Color
    let panelPrimaryText: Color
    let panelSecondaryText: Color
    let readButtonColor: Color
    let historyButtonColor: Color
    let openButtonColor: Color
    let toggleFillColor: Color
    let toggleIconColor: Color
    let copyButtonFill: Color
    let copyIconColor: Color
    let buttonLabelOnColor: Color
}
```

Style rules we follow consistently:
- Cards: `RoundedRectangle(cornerRadius: 16).fill(palette.cardBackground)` + 1pt border with `palette.cardBorder`.
- Nav cards: slightly different “glass-ish” background (`palette.navBackground`) + border `palette.navBorder`.
- Typography: large page title (42 bold), body (24), captions (18), code (20 mono). (These are also baked into paging metrics.)


2) App-level immersive scene plumbing (required)
------------------------------------------------

The curved layout is a 3D placement problem; it MUST be rendered in an `ImmersiveSpace` using
`RealityView` attachments. If you put these SwiftUI views into a normal `WindowGroup`, you lose:
- head tracking anchor
- world anchors for “dropped boards”
- stable curved layout in meters

App scene setup (excerpt):

```swift
// Sources/GravitasReader/GravitasReaderApp.swift

ImmersiveSpace(id: "ReadSpace") {
    ImmersiveReadSpace()
        .environmentObject(appModel)
        .environmentObject(podcastPlayer)
        .environmentObject(subscriptionManager)
        .environment(\.colorScheme, colorScheme)
}
.immersionStyle(selection: .constant(style), in: .mixed)
.immersiveEnvironmentBehavior(.coexist)
```

And BEFORE placing content, we ensure the immersive space is open:

```swift
// Sources/GravitasReader/ControlPanelView.swift

@MainActor
private func ensureReadSpaceOpen() async {
    if immersiveOpen || openingInFlight { return }
    openingInFlight = true
    _ = await openImmersiveSpace(id: "ReadSpace")
    immersiveOpen = true
    openingInFlight = false
}
```

This is not optional. If you spawn boards before `openImmersiveSpace`, you will “drop” placements
but won’t see them, and your head-tracked spawn transform may be wrong/uninitialized.


3) IMPORTANT: exact spawn positions for dropped boards (world anchors)
----------------------------------------------------------------------

Each article placement gets its own RealityKit `AnchorEntity(world:)`.
If the placement already has a stored transform, we reuse it. Otherwise we create a deterministic
spawn transform based on the user’s head pose at spawn time.

Keep these constants EXACT to match Gravitas behavior:
- `headForwardOffset = 0.09` meters (board drops ~9cm forward from head)
- Lateral “lanes” (meters): `[0, 0.35, -0.35, 0.7, -0.7, 1.05, -1.05]`
- Depth nudge per row (meters): `0.05 * ((spawnIndex / lanes.count) % 3)`
- Default Y (meters): `1.35` (if head Y is not reliable); otherwise `pos.y -= 0.05`

Verbatim code:

```swift
// Sources/GravitasReader/ImmersiveSpaceView.swift

// Always produce an anchor; add spawn "scatter" so new boards don't overlap
private func makeAnchor(for placement: ArticlePlacement) -> AnchorEntity {
    if let stored = placement.anchorTransform {
        let a = AnchorEntity(world: stored)
        a.orientation = Transform(matrix: stored).rotation
        return a
    }

    // Start from head (or cached), else identity fallback
    let head = latestHeadTransform ?? captureHeadTransform() ?? Transform()
    let fcol = head.matrix.columns.2
    let forward = normalize(-SIMD3<Float>(fcol.x, fcol.y, fcol.z))
    let left = normalize(cross(SIMD3<Float>(0, 1, 0), forward))

    // Deterministic scatter so new boards are visibly offset even if the head hasn't moved
    let spawnIndex = model.placements.firstIndex(where: { $0.id == placement.id }) ?? (model.placements.count - 1)
    let lanes: [Float] = [0, 0.35, -0.35, 0.7, -0.7, 1.05, -1.05]
    let side = lanes[spawnIndex % lanes.count]
    let depthNudge: Float = 0.05 * Float((spawnIndex / lanes.count) % 3)

    var pos = head.translation + forward * (headForwardOffset + depthNudge) + left * side
    if !pos.y.isFinite || abs(pos.y) <= 0.001 { pos.y = 1.35 } else { pos.y -= 0.05 }

    var seeded = head
    seeded.translation = pos

    let anchor = AnchorEntity(world: seeded.matrix)
    anchor.orientation = seeded.rotation

    // Persist seeded transform back into the model once
    let matrix = seeded.matrix
    let pid = placement.id
    Task { @MainActor in
        model.assignTransform(matrix, to: pid)
    }

    return anchor
}
```

HUD spawn (head-anchored) is also exact:

```swift
let hudAnchor = AnchorEntity(.head)
hud.position = [0, -0.12, -1.0] // x,y,z in meters relative to head
hudAnchor.addChild(hud)
content.add(hudAnchor)
```


4) Curved “wall/arc” paged layout (RealityView attachments)
-----------------------------------------------------------

High-level:
- We render SwiftUI page views as `RealityView` attachments.
- We place each attachment Entity onto a curved arc around the placement anchor.
- We compute both position and rotation so each panel faces the user.

CRITICAL: Page geometry (meters) must match the page builder’s assumptions:
- `PageBuilder.pageWidthPoints = 620`
- `pointsPerMeter = 780`
- `columnMaxHeight = 2.4` meters

The layout constants below are tuned together (keep them exact to match current behavior):

```
panelDepthOffset = 0.03
targetPanelDistance = 0.25
pageSpacing = 0.03
arcSpacingRadians = π / 18   (≈10°)
maxFanDegrees = 160
canonicalTotalSlots = 12
minRadiusMeters = 0.90
maxArcRadius = 2.1
panelWidthPoints = 620
pointsPerMeter = 780
neighborGapMeters = 0.015
```

Core loop (verbatim excerpt) that creates the curved arc:

```swift
// Sources/GravitasReader/ImmersiveSpaceView.swift

let pages = model.visiblePages(for: placement)
let layout = layoutColumns(for: pages)   // splits pages into columns by max height
let columns = layout.columns
let heights = layout.heights

let columnCount = columns.count
let desiredChord = panelWidthMeters + neighborGapMeters

let canonicalStep = maxFanRadians / Float(max(1, canonicalTotalSlots - 1))
let baseRadius = min(maxArcRadius,
                     max(minRadiusMeters,
                         desiredChord / max(0.001, 2 * sinf(canonicalStep / 2))))

var radius = max(minRadiusMeters, targetPanelDistance + 0.08)
var slotStep: Float = 0
var angles: [Float] = []

if columnCount <= canonicalPanelSlots {
    radius = max(radius, baseRadius)
    slotStep = canonicalStep
    angles = canonicalPanelAngles(count: columnCount, step: canonicalStep)
} else if columnCount > 1 {
    let allowedStep = maxFanRadians / Float(columnCount - 1)
    let stepAtRadius = 2 * asinf(min(0.999, desiredChord / (2 * radius)))
    var step = max(arcSpacingRadians, stepAtRadius)

    if step > allowedStep {
        let requiredR = desiredChord / (2 * sinf(allowedStep / 2))
        radius = min(maxArcRadius, max(radius, requiredR))
        step = allowedStep
    } else {
        let requiredR = desiredChord / (2 * sinf(step / 2))
        radius = min(maxArcRadius, max(radius, requiredR))
    }

    slotStep = step
    let centeredOffset = Float(columnCount - 1) / 2
    angles = (0..<columnCount).map { (Float($0) - centeredOffset) * slotStep }
} else {
    slotStep = canonicalStep
    radius = max(radius, targetPanelDistance + 0.20)
    angles = [0]
}

for (columnIndex, column) in columns.enumerated() {
    let angle = columnIndex < angles.count ? angles[columnIndex] : (Float(columnIndex) * slotStep)
    let sine = sin(angle)
    let cosine = cos(angle)
    let horizontalOffset = sine * radius
    let depthOffset = -cosine * radius - panelDepthOffset
    let totalHeight = heights[columnIndex]
    var yCursor = -totalHeight / 2

    for (itemOffset, pageIndex) in column.enumerated() {
        let page = pages[pageIndex]
        let attachmentID = panelAttachmentID(for: placement, pageId: page.id)
        let yMid = yCursor + page.heightMeters / 2

        if let panel = attachments.entity(for: attachmentID) {
            var transform = panel.transform
            transform.translation = [horizontalOffset, yMid, depthOffset]

            // Make the panel face the user (so text is readable).
            let forward = normalize(SIMD3<Float>(-horizontalOffset, 0, -depthOffset))
            let right = normalize(cross(SIMD3<Float>(0, 1, 0), forward))
            let up = cross(forward, right)
            transform.rotation = simd_quatf(float3x3(columns: (right, up, forward)))

            panel.transform = transform
            panel.name = "Panel:\(attachmentID)"
            if panel.parent != root { root.addChild(panel) }
        }

        yCursor = yMid + page.heightMeters / 2
        if itemOffset != column.count - 1 { yCursor += pageSpacing }
    }
}
```


5) Pagination (paged mode) + nav cards
--------------------------------------

Pagination model:
- We keep a per-placement “window index” (`pageWindows[placementID]`) where each window is 10 pages.
- The immersive view only renders the visible window (up to 10 pages, then columnized/curved).

Code excerpt (copied from `Sources/GravitasReader/AppModel.swift`; keep the logic + constants in sync):

```swift
// Sources/GravitasReader/AppModel.swift

let pageWindowSize: Int = 10
@Published private(set) var pageWindows: [UUID: Int] = [:]

func visiblePages(for placement: ArticlePlacement) -> [ArticlePage] {
    let total = placement.pagesSnapshot.count
    guard total > 0 else { return [] }
    let start = currentPageStart(for: placement.id, total: total)
    let end = min(start + pageWindowSize, total)
    return Array(placement.pagesSnapshot[start..<end])
}

func canPageBack(_ placement: ArticlePlacement) -> Bool {
    let total = placement.pagesSnapshot.count
    guard total > 0 else { return false }
    return currentPageIndex(for: placement.id, total: total) > 0
}

func canPageForward(_ placement: ArticlePlacement) -> Bool {
    let total = placement.pagesSnapshot.count
    guard total > 0 else { return false }
    let index = currentPageIndex(for: placement.id, total: total)
    return index < maxPageIndex(total: total)
}

func pageBack(_ placement: ArticlePlacement) {
    let total = placement.pagesSnapshot.count
    guard total > 0 else { return }
    let oldIndex = currentPageIndex(for: placement.id, total: total)
    let newIndex = max(0, oldIndex - 1)
    pageWindows[placement.id] = newIndex
    updateBookSession(for: placement, windowIndex: newIndex)
    GRLog.p("Pager", "Back pid=\(placement.id) page=\(oldIndex) -> \(newIndex) totalPages=\(maxPageIndex(total: total) + 1)")
    objectWillChange.send()
}

func pageForward(_ placement: ArticlePlacement) {
    let total = placement.pagesSnapshot.count
    guard total > 0 else { return }
    let oldIndex = currentPageIndex(for: placement.id, total: total)
    let newIndex = min(oldIndex + 1, maxPageIndex(total: total))
    pageWindows[placement.id] = newIndex
    updateBookSession(for: placement, windowIndex: newIndex)
    GRLog.p("Pager", "Forward pid=\(placement.id) page=\(oldIndex) -> \(newIndex) totalPages=\(maxPageIndex(total: total) + 1)")
    objectWillChange.send()
}

private func currentPageIndex(for placementID: UUID, total: Int) -> Int {
    let rawIndex = pageWindows[placementID] ?? 0
    let maxIndex = maxPageIndex(total: total)
    return max(0, min(rawIndex, maxIndex))
}

private func currentPageStart(for placementID: UUID, total: Int) -> Int {
    let index = currentPageIndex(for: placementID, total: total)
    return index * pageWindowSize
}

private func maxPageIndex(total: Int) -> Int {
    return max(0, (total - 1) / pageWindowSize)
}
```

Nav UI is just 2 attachments placed at angles outside the curved panel cluster:
- `NavCardView(direction: .prev/.next, enabled: canPageBack/canPageForward, action: pageBack/pageForward)`
- Nav placement uses the same “face the user” rotation math as panels.


6) Vertical ScrollView layout mode (single big panel)
-----------------------------------------------------

We support a “Scroll” mode where the article is rendered in one tall vertical scroll view.
In immersive space, this scroll panel is placed straight ahead and scaled up.

Keep these constants EXACT (immersive placement tuning):
- `scrollPanelHeightPoints = 980`
- `scrollPanelDepthPaddingMeters = 1.9`
- `scrollPanelScale = 1.85`

Immersive placement excerpt:

```swift
// Sources/GravitasReader/ImmersiveSpaceView.swift

let radius = max(minRadiusMeters, targetPanelDistance + scrollPanelDepthPaddingMeters)
let x: Float = 0
let z = -radius - panelDepthOffset
transform.translation = [x, 0, z]
// rotation faces user (same math as paged panels)
panel.scale = [scrollPanelScale, scrollPanelScale, scrollPanelScale]
```

SwiftUI ScrollView excerpt (shows look-based scrolling on visionOS and anchor tracking for books):

```swift
// Sources/GravitasReader/ArticlePresentation.swift

struct ArticleScrollView: View {
    let article: Article
    let palette: ReaderThemePalette
    let contentWidth: CGFloat
    @EnvironmentObject private var model: AppModel
    @State private var hasAppliedInitialAnchor = false
    @State private var lastReportedBlockID: UUID?
    @State private var pendingAnchorID: UUID?
    @State private var canReportPositions = false
    @State private var lastAnchorRecordDate: Date = .distantPast

    private let anchorRecordThrottle: TimeInterval = 1.5
    private var scrollSpaceName: String { "ArticleScroll-\(article.id.uuidString)" }

    var body: some View {
        ScrollViewReader { proxy in
            ScrollView(.vertical) {
                VStack(alignment: .leading, spacing: 18) {
                    // headerIfNeeded()
                    // blocks...
                    Spacer(minLength: 6)
                }
                .frame(maxWidth: contentWidth)
                .padding(.vertical, 28)
                .padding(.horizontal, 28)
                .background(RoundedRectangle(cornerRadius: 16).fill(palette.cardBackground))
                .overlay(RoundedRectangle(cornerRadius: 16).stroke(palette.cardBorder, lineWidth: 1))
                .padding(.horizontal)
            }
            .coordinateSpace(name: scrollSpaceName)
            .scrollIndicators(.visible)
        #if os(visionOS)
            .scrollInputBehavior(.enabled, for: .look)
        #endif
        }
        .id(article.id)
    }
}
```

The production implementation includes a `PreferenceKey`-based geometry reporter to compute the
nearest visible block and persist it as a “scroll anchor” in the model for resume-on-reopen.
See `ArticleScrollPositionKey` and `BlockScrollPositionReporter` in `ArticlePresentation.swift`.


7) Glue: “paged vs scroll” selection
------------------------------------

We select layout mode per-article:
- non-books use a default (`defaultReaderLayoutMode`)
- books choose based on format (wide → paged, narrow → scroll)

Verbatim:

```swift
// Sources/GravitasReader/AppModel.swift

func layoutMode(for article: Article) -> ReaderLayoutMode? {
    if let bookID = article.bookID {
        let isWide = bookSessions[bookID]?.formatIsWide ?? defaultBookSession().formatIsWide
        return isWide ? .paged : .scroll
    } else {
        return defaultReaderLayoutMode
    }
}
```


8) RealityView anchoring + dynamic attachments lifecycle (the “entire system”)
------------------------------------------------------------------------------

This is the critical architecture that makes the immersive reader “draw in space” and stay dynamic:

- The model owns *data* (`placements`, pages, etc.)
- `RealityView` owns the *scene graph*
- SwiftUI attachments own the *rendered panels* (as textures on RealityKit entities)

The pipeline in 3 pieces:

8.1) Data model: placements are immutable “what to render”

An `ArticlePlacement` contains:
- an ID
- a per-instance token (used to namespace attachment IDs)
- optional persisted world transform (`anchorTransform`)
- a snapshot of prebuilt pages (`pagesSnapshot`)

```swift
// Sources/GravitasReader/ReaderState.swift

struct ArticlePlacement: Identifiable {
    let id: UUID
    let instanceToken: UUID
    var article: Article
    var anchorTransform: simd_float4x4?
    let pagesSnapshot: [ArticlePage]
    let theaterLayout: TheaterLayout?
    let createdAt: Date

    var attachmentsPrefix: String { "Inst:\(instanceToken.uuidString)" }
}
```

8.2) Runtime scene: one world anchor + one root entity per placement

We keep a private runtime dictionary keyed by placement ID:
- `AnchorEntity(world:)` is the placement’s world-space anchor
- `root` is where we parent all panel/nav entities for this placement

```swift
// Sources/GravitasReader/ImmersiveSpaceView.swift

private final class RuntimePlacement {
    let anchor: AnchorEntity
    let root: Entity
    init(anchor: AnchorEntity, root: Entity) { self.anchor = anchor; self.root = root }
}
```

8.3) RealityView: render loop + attachments loop

RealityView has three parts:
- initial `content` phase
- per-frame `update`
- `attachments` builder (SwiftUI → RealityKit entities)

```swift
// Sources/GravitasReader/ImmersiveSpaceView.swift

struct ImmersiveReadSpace: View {
    @EnvironmentObject private var model: AppModel
    @State private var runtimePlacements: [UUID: RuntimePlacement] = [:]
    @State private var headTracker: AnchorEntity?
    @State private var latestHeadTransform: Transform?

    var body: some View {
        RealityView { content, attachments in
            ensureHeadTracker(in: content)
            syncScene(content: content, attachments: attachments)
        } update: { content, attachments in
            ensureHeadTracker(in: content)
            syncScene(content: content, attachments: attachments)
        } attachments: {
            ForEach(model.placements) { placement in
                // Paged mode pages + nav cards (or scroll/theater variants).
                // Attachment IDs MUST be stable & unique.
                Attachment(id: navAttachmentID(for: placement, direction: .prev)) { /* ... */ }
                Attachment(id: navAttachmentID(for: placement, direction: .next)) { /* ... */ }
                ForEach(model.visiblePages(for: placement)) { page in
                    Attachment(id: panelAttachmentID(for: placement, pageId: page.id)) {
                        ArticleCardView(article: placement.article, page: page, palette: model.palette)
                            .frame(width: 620, height: page.viewHeight)
                    }
                }
            }
        }
    }
}
```

8.4) Head tracking is required (for spawn + “face the user” math)

We attach an `AnchorEntity(.head)` to the RealityView content and cache its transform every frame.

```swift
private func ensureHeadTracker(in content: RealityViewContent) {
    if headTracker == nil { headTracker = AnchorEntity(.head) }
    if let tracker = headTracker {
        if tracker.parent == nil { content.add(tracker) }
        latestHeadTransform = Transform(matrix: tracker.transformMatrix(relativeTo: nil))
    }
}
```

8.5) Stable attachment IDs (this is non-negotiable)

If IDs collide across placements, or change between frames, the wrong entity will be reused and you’ll
see panels “swap” content or flicker. We avoid this by namespacing everything with `instanceToken`.

```swift
private func navAttachmentID(for placement: ArticlePlacement, direction: NavDirection) -> String {
    "\(placement.attachmentsPrefix):Placement=\(placement.id.uuidString):Nav=\(direction == .prev ? "Prev" : "Next")"
}

private func scrollAttachmentID(for placement: ArticlePlacement) -> String {
    "\(placement.attachmentsPrefix):Placement=\(placement.id.uuidString):Scroll"
}

private func panelAttachmentID(for placement: ArticlePlacement, pageId: Int) -> String {
    "\(placement.attachmentsPrefix):Placement=\(placement.id.uuidString):Page=\(pageId)"
}
```

8.6) Dynamic sync + cleanup (how it “stays correct”)

Each frame:
- create runtime placement (anchor+root) if missing
- add anchors to `content` if not already present
- place any currently-available attachment entities under the root
- remove any stale entities (pages/navs no longer visible)
- remove runtime placements that disappeared from `model.placements`

```swift
// Sources/GravitasReader/ImmersiveSpaceView.swift (excerpt)

private func syncScene(content: RealityViewContent, attachments: RealityViewAttachments) {
    var updatedPlacements = runtimePlacements
    var stale = Set(updatedPlacements.keys)

    for placement in model.placements {
        let pid = placement.id
        stale.remove(pid)

        let runtime: RuntimePlacement
        if let existing = updatedPlacements[pid] {
            runtime = existing
        } else {
            let anchor = makeAnchor(for: placement)
            let root = Entity()
            anchor.addChild(root)
            runtime = RuntimePlacement(anchor: anchor, root: root)
            updatedPlacements[pid] = runtime
        }

        if runtime.anchor.parent == nil { content.add(runtime.anchor) }
        if runtime.root.parent !== runtime.anchor {
            runtime.anchor.addChild(runtime.root)
            runtime.root.transform = .identity
        }

        // ...choose layout mode (theater/scroll/paged) and place panels/navs...
        // ...remove children not in the new "valid" sets...
    }

    for id in stale {
        if let runtime = updatedPlacements.removeValue(forKey: id) {
            runtime.anchor.removeFromParent()
        }
    }

    DispatchQueue.main.async { self.runtimePlacements = updatedPlacements }
}
```

8.7) Performance: incremental attachment loading (keeps “dynamic” from becoming “janky”)

Paged mode can have up to 10 pages visible per placement; each page is a large SwiftUI view.
We don’t create them all at once — we “ramp” attachments in batches:

- `initialPanelBatchSize = 2`
- `panelBatchStep = 2`
- track per-placement load counts in `panelLoadCounts`
- in `attachments`, only render `windowPages.prefix(loadCount)`

```swift
// Sources/GravitasReader/ImmersiveSpaceView.swift (excerpt)

let windowPages = model.visiblePages(for: placement)
let loadCount = panelLoadCounts[placement.id] ?? min(max(windowPages.count, 0), initialPanelBatchSize)
let limitedPages = Array(windowPages.prefix(loadCount))
ForEach(limitedPages) { page in
    Attachment(id: panelAttachmentID(for: placement, pageId: page.id)) { /* ... */ }
}
```

This is especially important when pages contain multiple images/video/PDF previews.


9) Dynamic media loading + “fill the panel” behavior (images, PDFs, video)
---------------------------------------------------------------------------

The key trick is: **panel geometry must be stable even while media is loading.**
We do that by precomputing layout metrics (height in meters + points) and then giving images a fixed
frame based on those metrics, so `AsyncImage` loading doesn’t change the panel size in 3D.

9.1) Page geometry: meters for layout, points for SwiftUI

```swift
// Sources/GravitasReader/PageLayout.swift

struct ArticlePage: Identifiable {
    struct Item: Identifiable {
        let id = UUID()
        let block: ArticleBlock
        let imageHeightPoints: CGFloat?
    }

    let id: Int
    let items: [Item]
    let showHeader: Bool
    let heightMeters: Float
    let viewHeight: CGFloat
}
```

- `heightMeters` is used by the curved layout to stack pages in space.
- `viewHeight` is used by SwiftUI (`.frame(height: ...)`) so the attachment entity’s physical height matches.

9.2) Media sizing: use `imageHeightPoints` if available (avoids layout shift)

```swift
// Sources/GravitasReader/ArticlePresentation.swift (excerpt)

private static func mediaDimensions(for item: ArticlePage.Item, contentWidth: CGFloat) -> CGSize? {
    let innerWidth = max(contentWidth - 56, 240)
    let minHeight: CGFloat = 220
    let minWidth: CGFloat = 240

    switch item.block.kind {
    case .image, .video:
        if let points = item.imageHeightPoints, points > 0 {
            let scale = innerWidth / 620
            var scaledHeight = max(minHeight, CGFloat(points) * scale)
            let portraitCap = innerWidth * 1.8
            if scaledHeight > portraitCap { scaledHeight = portraitCap }
            return CGSize(width: max(minWidth, innerWidth), height: scaledHeight)
        }

        guard let w = item.block.originalWidth, let h = item.block.originalHeight, w > 0 else {
            return CGSize(width: innerWidth, height: max(minHeight, innerWidth * 0.6))
        }

        let aspect = CGFloat(h) / CGFloat(w)
        var computedHeight = innerWidth * aspect
        if aspect <= 1 {
            if computedHeight < minHeight { computedHeight = minHeight }
        } else {
            computedHeight = min(computedHeight, innerWidth * 1.8)
        }
        return CGSize(width: innerWidth, height: computedHeight)

    case .pdfDocument:
        return CGSize(width: innerWidth, height: max(minHeight, innerWidth * 1.3))

    default:
        return nil
    }
}
```

9.3) Image loading: remote (`AsyncImage`) vs local (`LocalImageView`)

Remote images:
- fixed frame based on `mediaSize`
- `.scaledToFit()` to avoid cropping
- placeholders for empty/failure

```swift
// Sources/GravitasReader/ArticlePresentation.swift (excerpt)

case .image:
    if let url = item.block.imageURL {
        let mediaSize = mediaSize(for: item)
        HStack {
            Spacer(minLength: 0)
            Group {
                if url.isFileURL {
                    LocalImageView(url: url,
                                   placeholderColor: palette.secondaryText.opacity(0.15),
                                   placeholderIconColor: palette.secondaryText)
                        .scaledToFit()
                } else {
                    AsyncImage(url: url) { phase in
                        switch phase {
                        case .success(let image): image.resizable().scaledToFit()
                        case .failure:
                            ZStack {
                                palette.secondaryText.opacity(0.15)
                                Image(systemName: "photo")
                                    .font(.system(size: 40, weight: .light))
                                    .foregroundStyle(palette.secondaryText)
                            }
                        case .empty: ProgressView()
                        @unknown default: ProgressView()
                        }
                    }
                }
            }
            .frame(width: mediaSize.width, height: mediaSize.height)
            .clipShape(RoundedRectangle(cornerRadius: 12))
            Spacer(minLength: 0)
        }
    }
```

Local images (e.g. extracted from a PDF) are loaded off the main thread to keep scrolling smooth:

```swift
// Sources/GravitasReader/ArticlePresentation.swift (verbatim)

private struct LocalImageView: View {
    let url: URL
    let placeholderColor: Color
    let placeholderIconColor: Color

    @State private var image: UIImage?
    @State private var isLoading = false
    @State private var loadError = false

    var body: some View {
        ZStack {
            Rectangle().fill(placeholderColor)
            if let image {
                Image(uiImage: image).resizable().scaledToFit()
            } else if loadError {
                Image(systemName: "photo")
                    .font(.system(size: 36, weight: .light))
                    .foregroundStyle(placeholderIconColor)
            } else {
                ProgressView().progressViewStyle(.circular)
            }
        }
        .onAppear(perform: loadIfNeeded)
    }

    private func loadIfNeeded() {
        guard !isLoading, image == nil, !loadError else { return }
        isLoading = true
        DispatchQueue.global(qos: .userInitiated).async {
            defer { DispatchQueue.main.async { self.isLoading = false } }
            guard let data = try? Data(contentsOf: url),
                  let img = UIImage(data: data) else {
                DispatchQueue.main.async { self.loadError = true }
                return
            }
            DispatchQueue.main.async { self.image = img }
        }
    }
}
```

9.4) PDF previews in panels (PDFKit)

PDF blocks get an inline preview using a `UIViewRepresentable` wrapper around `PDFView`.
This lets PDFs render inside the same fixed media frame (so layout remains stable).

```swift
// Sources/GravitasReader/ArticlePresentation.swift (excerpt)

case .pdfDocument:
    let mediaSize = mediaSize(for: item)
    VStack(alignment: .leading, spacing: 10) {
        if let url = item.block.pdfURL {
            PDFDisplayView(url: url)
                .frame(width: mediaSize.width, height: mediaSize.height)
                .clipShape(RoundedRectangle(cornerRadius: 12))
                .overlay(
                    RoundedRectangle(cornerRadius: 12)
                        .stroke(palette.cardBorder.opacity(0.25), lineWidth: 1)
                )
        } else {
            ZStack {
                palette.secondaryText.opacity(0.12)
                Image(systemName: "doc.richtext")
                    .font(.system(size: 40, weight: .semibold))
                    .foregroundStyle(palette.secondaryText)
            }
            .frame(width: mediaSize.width, height: mediaSize.height)
            .clipShape(RoundedRectangle(cornerRadius: 12))
        }
    }
```

```swift
// Sources/GravitasReader/ArticlePresentation.swift (verbatim)

private struct PDFDisplayView: UIViewRepresentable {
    let url: URL

    func makeUIView(context: Context) -> PDFView {
        let view = PDFView()
        view.autoScales = true
        view.displayMode = .singlePageContinuous
        view.displayDirection = .vertical
        view.usePageViewController(true, withViewOptions: nil)
        view.backgroundColor = .clear
        view.document = PDFDocument(url: url)
        return view
    }

    func updateUIView(_ uiView: PDFView, context: Context) {
        guard uiView.document?.documentURL != url else { return }
        uiView.document = PDFDocument(url: url)
    }
}
```

9.5) Why this stays dynamic in immersive space

- Attachments are SwiftUI views; when an `AsyncImage` finishes, SwiftUI re-renders the attachment.
- RealityKit updates the underlying texture automatically; you don’t “rebuild meshes”.
- Because the media frame is fixed (via precomputed sizing), the panel’s 3D footprint does not jump.


Summary checklist (what must exist in a new project)
----------------------------------------------------

1) Styling
   - `ReaderTheme` + `ReaderThemePalette` (semantic colors only)
   - Views accept a `palette` and never hardcode colors

2) Immersive scene
   - `ImmersiveSpace(id: "ReadSpace") { ImmersiveReadSpace() }`
   - Ensure it is opened via `openImmersiveSpace(id: "ReadSpace")` before spawning placements

3) Spawn positions (do not change)
   - Head-relative spawn with exact `lanes` + `headForwardOffset` + default y=1.35

4) Curved layout
   - Place SwiftUI attachments as RealityKit entities
   - Arc positioning: x=sin(angle)*radius, z=-cos(angle)*radius, face-user rotation
   - Keep `pointsPerMeter` and page width in sync with the page builder

5) Pagination
   - Per-placement page window state + Prev/Next nav cards

6) Scroll layout
   - Single large vertical ScrollView panel, placed straight ahead and scaled
   - (visionOS) enable look-based scrolling

7) Anchoring + attachments lifecycle
   - Runtime map: placementID → (world `AnchorEntity`, root `Entity`)
   - Stable, unique attachment IDs (namespace with an instance token)
   - Per-frame sync that re-parents entities and cleans up stale ones
   - Incremental attachment loading for performance

8) Dynamic media filling
   - Stable panel geometry: `heightMeters` + `viewHeight`
   - Fixed media frames for images/PDF/video so async loading doesn’t shift 3D layout
